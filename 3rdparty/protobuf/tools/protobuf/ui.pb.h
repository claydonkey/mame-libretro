// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ui.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ui_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ui_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ui_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ui_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ui_2eproto;
namespace m_st {
class Fps;
struct FpsDefaultTypeInternal;
extern FpsDefaultTypeInternal _Fps_default_instance_;
class Settings;
struct SettingsDefaultTypeInternal;
extern SettingsDefaultTypeInternal _Settings_default_instance_;
class Stats;
struct StatsDefaultTypeInternal;
extern StatsDefaultTypeInternal _Stats_default_instance_;
class TextPos;
struct TextPosDefaultTypeInternal;
extern TextPosDefaultTypeInternal _TextPos_default_instance_;
class Timer;
struct TimerDefaultTypeInternal;
extern TimerDefaultTypeInternal _Timer_default_instance_;
class messageSettings;
struct messageSettingsDefaultTypeInternal;
extern messageSettingsDefaultTypeInternal _messageSettings_default_instance_;
}  // namespace m_st
PROTOBUF_NAMESPACE_OPEN
template<> ::m_st::Fps* Arena::CreateMaybeMessage<::m_st::Fps>(Arena*);
template<> ::m_st::Settings* Arena::CreateMaybeMessage<::m_st::Settings>(Arena*);
template<> ::m_st::Stats* Arena::CreateMaybeMessage<::m_st::Stats>(Arena*);
template<> ::m_st::TextPos* Arena::CreateMaybeMessage<::m_st::TextPos>(Arena*);
template<> ::m_st::Timer* Arena::CreateMaybeMessage<::m_st::Timer>(Arena*);
template<> ::m_st::messageSettings* Arena::CreateMaybeMessage<::m_st::messageSettings>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace m_st {

enum Protocol : int {
  SERVER_PROTO_UDP = 0,
  SERVER_PROTO_TCP = 1,
  Protocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Protocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Protocol_IsValid(int value);
constexpr Protocol Protocol_MIN = SERVER_PROTO_UDP;
constexpr Protocol Protocol_MAX = SERVER_PROTO_TCP;
constexpr int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Protocol_descriptor();
template<typename T>
inline const std::string& Protocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Protocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Protocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Protocol_descriptor(), enum_t_value);
}
inline bool Protocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Protocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
enum Orientation : int {
  DEFAULT_ORIENTATION = 0,
  ROT_90 = 1,
  ROT_180 = 2,
  ROT_270 = 3,
  FLIP_X = 4,
  FLIP_Y = 5,
  FLIP_XY = 6,
  Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Orientation_IsValid(int value);
constexpr Orientation Orientation_MIN = DEFAULT_ORIENTATION;
constexpr Orientation Orientation_MAX = FLIP_XY;
constexpr int Orientation_ARRAYSIZE = Orientation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Orientation_descriptor();
template<typename T>
inline const std::string& Orientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Orientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Orientation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Orientation_descriptor(), enum_t_value);
}
inline bool Orientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Orientation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Orientation>(
    Orientation_descriptor(), name, value);
}
enum BufferMode : int {
  DMA_NORMAL_MODE = 0,
  DMA_CIRCULAR_MODE = 1,
  DMA_PFCTRL_MODE = 2,
  DMA_DOUBLE_BUFFER_M0_MODE = 3,
  DMA_DOUBLE_BUFFER_M1_MODE = 4,
  BufferMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BufferMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BufferMode_IsValid(int value);
constexpr BufferMode BufferMode_MIN = DMA_NORMAL_MODE;
constexpr BufferMode BufferMode_MAX = DMA_DOUBLE_BUFFER_M1_MODE;
constexpr int BufferMode_ARRAYSIZE = BufferMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BufferMode_descriptor();
template<typename T>
inline const std::string& BufferMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BufferMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BufferMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BufferMode_descriptor(), enum_t_value);
}
inline bool BufferMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BufferMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BufferMode>(
    BufferMode_descriptor(), name, value);
}
enum Mode : int {
  NO_MODE = 0,
  SERVER = 1,
  V3D = 2,
  EMU = 3,
  PAGES = 4,
  OPENGL = 5,
  MUSIC = 6,
  ILDA = 7,
  UI = 8,
  SVG = 9,
  CTRLS = 10,
  DVG = 11,
  ZIP = 12,
  SYS = 13,
  Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = NO_MODE;
constexpr Mode Mode_MAX = SYS;
constexpr int Mode_ARRAYSIZE = Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Mode_descriptor();
template<typename T>
inline const std::string& Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Mode_descriptor(), enum_t_value);
}
inline bool Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Mode>(
    Mode_descriptor(), name, value);
}
enum compressionFlags : int {
  LEVEL_NONE = 0,
  LEVEL_SAFE = 1,
  LEVEL_1 = 2,
  LEVEL_2 = 3,
  LEVEL_3 = 4,
  LEVEL_4 = 5,
  LEVEL_5 = 6,
  LEVEL_6 = 7,
  LEVEL_7 = 8,
  LEVEL_8 = 9,
  LEVEL_9 = 10,
  LEVEL_10 = 11,
  LEVEL_11 = 12,
  LEVEL_12 = 13,
  LEVEL_13 = 14,
  LEVEL_14 = 15,
  LEVEL_15 = 16,
  LEVEL_MAX = 17,
  compressionFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  compressionFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool compressionFlags_IsValid(int value);
constexpr compressionFlags compressionFlags_MIN = LEVEL_NONE;
constexpr compressionFlags compressionFlags_MAX = LEVEL_MAX;
constexpr int compressionFlags_ARRAYSIZE = compressionFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* compressionFlags_descriptor();
template<typename T>
inline const std::string& compressionFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, compressionFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function compressionFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    compressionFlags_descriptor(), enum_t_value);
}
inline bool compressionFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, compressionFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<compressionFlags>(
    compressionFlags_descriptor(), name, value);
}
enum uiFlags : int {
  UI_OFF = 0,
  SPINNER = 1,
  UART_DEBUG = 2,
  CRT_OVERLAY = 3,
  LCD_OVERLAY = 4,
  LCD_MIRROR = 5,
  SCREEN = 6,
  TIMINGS = 7,
  HAPTICS = 8,
  GEOM = 9,
  MODE = 10,
  MEM = 11,
  LOGO = 12,
  FPS = 13,
  SWITCHES = 14,
  FFT = 15,
  FRAME = 16,
  OVRFLOW = 17,
  POINTS = 18,
  FRAME_CPLXTY = 19,
  CONNECTED = 20,
  EMPTY = 21,
  uiFlags_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  uiFlags_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool uiFlags_IsValid(int value);
constexpr uiFlags uiFlags_MIN = UI_OFF;
constexpr uiFlags uiFlags_MAX = EMPTY;
constexpr int uiFlags_ARRAYSIZE = uiFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* uiFlags_descriptor();
template<typename T>
inline const std::string& uiFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, uiFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function uiFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    uiFlags_descriptor(), enum_t_value);
}
inline bool uiFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, uiFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<uiFlags>(
    uiFlags_descriptor(), name, value);
}
enum Pagetype : int {
  PAGE_OFF = 0,
  ANALOG_CLOCK = 1,
  DIGITAL_CLOCK = 2,
  ALPHABET = 3,
  LOREM = 4,
  SVG_TEST = 5,
  TEST_CARD = 6,
  Pagetype_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Pagetype_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Pagetype_IsValid(int value);
constexpr Pagetype Pagetype_MIN = PAGE_OFF;
constexpr Pagetype Pagetype_MAX = TEST_CARD;
constexpr int Pagetype_ARRAYSIZE = Pagetype_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Pagetype_descriptor();
template<typename T>
inline const std::string& Pagetype_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Pagetype>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Pagetype_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Pagetype_descriptor(), enum_t_value);
}
inline bool Pagetype_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pagetype* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Pagetype>(
    Pagetype_descriptor(), name, value);
}
enum Font : int {
  HERSHEY_FONT = 0,
  ASTEROIDS_FONT = 1,
  Font_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Font_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Font_IsValid(int value);
constexpr Font Font_MIN = HERSHEY_FONT;
constexpr Font Font_MAX = ASTEROIDS_FONT;
constexpr int Font_ARRAYSIZE = Font_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Font_descriptor();
template<typename T>
inline const std::string& Font_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Font>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Font_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Font_descriptor(), enum_t_value);
}
inline bool Font_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Font* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Font>(
    Font_descriptor(), name, value);
}
enum BufferType : int {
  DOUBLE_BUFFER = 0,
  SINGLE_BUFFER = 1,
  SINGLE_BUFFER_FIXED = 2,
  BufferType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BufferType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BufferType_IsValid(int value);
constexpr BufferType BufferType_MIN = DOUBLE_BUFFER;
constexpr BufferType BufferType_MAX = SINGLE_BUFFER_FIXED;
constexpr int BufferType_ARRAYSIZE = BufferType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BufferType_descriptor();
template<typename T>
inline const std::string& BufferType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BufferType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BufferType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BufferType_descriptor(), enum_t_value);
}
inline bool BufferType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BufferType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BufferType>(
    BufferType_descriptor(), name, value);
}
// ===================================================================

class TextPos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.TextPos) */ {
 public:
  inline TextPos() : TextPos(nullptr) {}
  ~TextPos() override;
  explicit PROTOBUF_CONSTEXPR TextPos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextPos(const TextPos& from);
  TextPos(TextPos&& from) noexcept
    : TextPos() {
    *this = ::std::move(from);
  }

  inline TextPos& operator=(const TextPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextPos& operator=(TextPos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextPos& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextPos* internal_default_instance() {
    return reinterpret_cast<const TextPos*>(
               &_TextPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TextPos& a, TextPos& b) {
    a.Swap(&b);
  }
  inline void Swap(TextPos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextPos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextPos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextPos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextPos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextPos& from) {
    TextPos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextPos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.TextPos";
  }
  protected:
  explicit TextPos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYFieldNumber = 1,
    kXFieldNumber = 2,
  };
  // uint32 y = 1;
  void clear_y();
  uint32_t y() const;
  void set_y(uint32_t value);
  private:
  uint32_t _internal_y() const;
  void _internal_set_y(uint32_t value);
  public:

  // uint32 x = 2;
  void clear_x();
  uint32_t x() const;
  void set_x(uint32_t value);
  private:
  uint32_t _internal_x() const;
  void _internal_set_x(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.TextPos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t y_;
    uint32_t x_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// -------------------------------------------------------------------

class Settings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.Settings) */ {
 public:
  inline Settings() : Settings(nullptr) {}
  ~Settings() override;
  explicit PROTOBUF_CONSTEXPR Settings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Settings(const Settings& from);
  Settings(Settings&& from) noexcept
    : Settings() {
    *this = ::std::move(from);
  }

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Settings& operator=(Settings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Settings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Settings* internal_default_instance() {
    return reinterpret_cast<const Settings*>(
               &_Settings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Settings& a, Settings& b) {
    a.Swap(&b);
  }
  inline void Swap(Settings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Settings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Settings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Settings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Settings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Settings& from) {
    Settings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Settings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.Settings";
  }
  protected:
  explicit Settings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDacPeriodFieldNumber = 1,
    kDrawStepsFieldNumber = 2,
    kDwellFieldNumber = 3,
    kFineTypeFieldNumber = 4,
    kControllersFieldNumber = 5,
    kLcdFieldNumber = 6,
    kAudioFieldNumber = 7,
    kBufferModeFieldNumber = 10,
    kBufferTypeFieldNumber = 11,
    kScalexFieldNumber = 12,
    kScaleyFieldNumber = 13,
    kOrientationFieldNumber = 14,
    kUiFlagsFieldNumber = 15,
    kRomsizeFieldNumber = 16,
    kDispTriNumFieldNumber = 17,
    kDispSegNumFieldNumber = 18,
    kStlTriNumFieldNumber = 19,
    kDrawJumpsFieldNumber = 8,
    kAutoSyncFieldNumber = 9,
    kInFreertosFieldNumber = 28,
    kRgbFieldNumber = 31,
    kStlTriMemFieldNumber = 20,
    kFrameCtrFieldNumber = 21,
    kAppDacPeriodFieldNumber = 22,
    kAppDrawStepsFieldNumber = 23,
    kMinxFieldNumber = 24,
    kMinyFieldNumber = 25,
    kMaxxFieldNumber = 26,
    kMaxyFieldNumber = 27,
    kProtocolFieldNumber = 29,
    kCompressionLevelFieldNumber = 30,
    kMoveStepsFieldNumber = 32,
    kStatsFieldNumber = 33,
    kXOffsetFieldNumber = 34,
    kYOffsetFieldNumber = 35,
  };
  // uint32 dac_period = 1;
  void clear_dac_period();
  uint32_t dac_period() const;
  void set_dac_period(uint32_t value);
  private:
  uint32_t _internal_dac_period() const;
  void _internal_set_dac_period(uint32_t value);
  public:

  // uint32 draw_steps = 2;
  void clear_draw_steps();
  uint32_t draw_steps() const;
  void set_draw_steps(uint32_t value);
  private:
  uint32_t _internal_draw_steps() const;
  void _internal_set_draw_steps(uint32_t value);
  public:

  // uint32 dwell = 3;
  void clear_dwell();
  uint32_t dwell() const;
  void set_dwell(uint32_t value);
  private:
  uint32_t _internal_dwell() const;
  void _internal_set_dwell(uint32_t value);
  public:

  // bool fine_type = 4;
  void clear_fine_type();
  bool fine_type() const;
  void set_fine_type(bool value);
  private:
  bool _internal_fine_type() const;
  void _internal_set_fine_type(bool value);
  public:

  // bool controllers = 5;
  void clear_controllers();
  bool controllers() const;
  void set_controllers(bool value);
  private:
  bool _internal_controllers() const;
  void _internal_set_controllers(bool value);
  public:

  // bool lcd = 6;
  void clear_lcd();
  bool lcd() const;
  void set_lcd(bool value);
  private:
  bool _internal_lcd() const;
  void _internal_set_lcd(bool value);
  public:

  // bool audio = 7;
  void clear_audio();
  bool audio() const;
  void set_audio(bool value);
  private:
  bool _internal_audio() const;
  void _internal_set_audio(bool value);
  public:

  // .m_st.BufferMode buffer_mode = 10;
  void clear_buffer_mode();
  ::m_st::BufferMode buffer_mode() const;
  void set_buffer_mode(::m_st::BufferMode value);
  private:
  ::m_st::BufferMode _internal_buffer_mode() const;
  void _internal_set_buffer_mode(::m_st::BufferMode value);
  public:

  // .m_st.BufferType buffer_type = 11;
  void clear_buffer_type();
  ::m_st::BufferType buffer_type() const;
  void set_buffer_type(::m_st::BufferType value);
  private:
  ::m_st::BufferType _internal_buffer_type() const;
  void _internal_set_buffer_type(::m_st::BufferType value);
  public:

  // uint32 scalex = 12;
  void clear_scalex();
  uint32_t scalex() const;
  void set_scalex(uint32_t value);
  private:
  uint32_t _internal_scalex() const;
  void _internal_set_scalex(uint32_t value);
  public:

  // uint32 scaley = 13;
  void clear_scaley();
  uint32_t scaley() const;
  void set_scaley(uint32_t value);
  private:
  uint32_t _internal_scaley() const;
  void _internal_set_scaley(uint32_t value);
  public:

  // .m_st.Orientation orientation = 14;
  void clear_orientation();
  ::m_st::Orientation orientation() const;
  void set_orientation(::m_st::Orientation value);
  private:
  ::m_st::Orientation _internal_orientation() const;
  void _internal_set_orientation(::m_st::Orientation value);
  public:

  // uint32 ui_flags = 15;
  void clear_ui_flags();
  uint32_t ui_flags() const;
  void set_ui_flags(uint32_t value);
  private:
  uint32_t _internal_ui_flags() const;
  void _internal_set_ui_flags(uint32_t value);
  public:

  // uint32 romsize = 16;
  void clear_romsize();
  uint32_t romsize() const;
  void set_romsize(uint32_t value);
  private:
  uint32_t _internal_romsize() const;
  void _internal_set_romsize(uint32_t value);
  public:

  // uint32 disp_tri_num = 17;
  void clear_disp_tri_num();
  uint32_t disp_tri_num() const;
  void set_disp_tri_num(uint32_t value);
  private:
  uint32_t _internal_disp_tri_num() const;
  void _internal_set_disp_tri_num(uint32_t value);
  public:

  // uint32 disp_seg_num = 18;
  void clear_disp_seg_num();
  uint32_t disp_seg_num() const;
  void set_disp_seg_num(uint32_t value);
  private:
  uint32_t _internal_disp_seg_num() const;
  void _internal_set_disp_seg_num(uint32_t value);
  public:

  // uint32 stl_tri_num = 19;
  void clear_stl_tri_num();
  uint32_t stl_tri_num() const;
  void set_stl_tri_num(uint32_t value);
  private:
  uint32_t _internal_stl_tri_num() const;
  void _internal_set_stl_tri_num(uint32_t value);
  public:

  // bool draw_jumps = 8;
  void clear_draw_jumps();
  bool draw_jumps() const;
  void set_draw_jumps(bool value);
  private:
  bool _internal_draw_jumps() const;
  void _internal_set_draw_jumps(bool value);
  public:

  // bool auto_sync = 9;
  void clear_auto_sync();
  bool auto_sync() const;
  void set_auto_sync(bool value);
  private:
  bool _internal_auto_sync() const;
  void _internal_set_auto_sync(bool value);
  public:

  // bool in_freertos = 28;
  void clear_in_freertos();
  bool in_freertos() const;
  void set_in_freertos(bool value);
  private:
  bool _internal_in_freertos() const;
  void _internal_set_in_freertos(bool value);
  public:

  // bool rgb = 31;
  void clear_rgb();
  bool rgb() const;
  void set_rgb(bool value);
  private:
  bool _internal_rgb() const;
  void _internal_set_rgb(bool value);
  public:

  // uint32 stl_tri_mem = 20;
  void clear_stl_tri_mem();
  uint32_t stl_tri_mem() const;
  void set_stl_tri_mem(uint32_t value);
  private:
  uint32_t _internal_stl_tri_mem() const;
  void _internal_set_stl_tri_mem(uint32_t value);
  public:

  // uint32 frame_ctr = 21;
  void clear_frame_ctr();
  uint32_t frame_ctr() const;
  void set_frame_ctr(uint32_t value);
  private:
  uint32_t _internal_frame_ctr() const;
  void _internal_set_frame_ctr(uint32_t value);
  public:

  // uint32 app_dac_period = 22;
  void clear_app_dac_period();
  uint32_t app_dac_period() const;
  void set_app_dac_period(uint32_t value);
  private:
  uint32_t _internal_app_dac_period() const;
  void _internal_set_app_dac_period(uint32_t value);
  public:

  // uint32 app_draw_steps = 23;
  void clear_app_draw_steps();
  uint32_t app_draw_steps() const;
  void set_app_draw_steps(uint32_t value);
  private:
  uint32_t _internal_app_draw_steps() const;
  void _internal_set_app_draw_steps(uint32_t value);
  public:

  // uint32 minx = 24;
  void clear_minx();
  uint32_t minx() const;
  void set_minx(uint32_t value);
  private:
  uint32_t _internal_minx() const;
  void _internal_set_minx(uint32_t value);
  public:

  // uint32 miny = 25;
  void clear_miny();
  uint32_t miny() const;
  void set_miny(uint32_t value);
  private:
  uint32_t _internal_miny() const;
  void _internal_set_miny(uint32_t value);
  public:

  // uint32 maxx = 26;
  void clear_maxx();
  uint32_t maxx() const;
  void set_maxx(uint32_t value);
  private:
  uint32_t _internal_maxx() const;
  void _internal_set_maxx(uint32_t value);
  public:

  // uint32 maxy = 27;
  void clear_maxy();
  uint32_t maxy() const;
  void set_maxy(uint32_t value);
  private:
  uint32_t _internal_maxy() const;
  void _internal_set_maxy(uint32_t value);
  public:

  // .m_st.Protocol protocol = 29;
  void clear_protocol();
  ::m_st::Protocol protocol() const;
  void set_protocol(::m_st::Protocol value);
  private:
  ::m_st::Protocol _internal_protocol() const;
  void _internal_set_protocol(::m_st::Protocol value);
  public:

  // .m_st.compressionFlags compressionLevel = 30;
  void clear_compressionlevel();
  ::m_st::compressionFlags compressionlevel() const;
  void set_compressionlevel(::m_st::compressionFlags value);
  private:
  ::m_st::compressionFlags _internal_compressionlevel() const;
  void _internal_set_compressionlevel(::m_st::compressionFlags value);
  public:

  // uint32 move_steps = 32;
  void clear_move_steps();
  uint32_t move_steps() const;
  void set_move_steps(uint32_t value);
  private:
  uint32_t _internal_move_steps() const;
  void _internal_set_move_steps(uint32_t value);
  public:

  // bool stats = 33;
  void clear_stats();
  bool stats() const;
  void set_stats(bool value);
  private:
  bool _internal_stats() const;
  void _internal_set_stats(bool value);
  public:

  // int32 x_offset = 34;
  void clear_x_offset();
  int32_t x_offset() const;
  void set_x_offset(int32_t value);
  private:
  int32_t _internal_x_offset() const;
  void _internal_set_x_offset(int32_t value);
  public:

  // int32 y_offset = 35;
  void clear_y_offset();
  int32_t y_offset() const;
  void set_y_offset(int32_t value);
  private:
  int32_t _internal_y_offset() const;
  void _internal_set_y_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.Settings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dac_period_;
    uint32_t draw_steps_;
    uint32_t dwell_;
    bool fine_type_;
    bool controllers_;
    bool lcd_;
    bool audio_;
    int buffer_mode_;
    int buffer_type_;
    uint32_t scalex_;
    uint32_t scaley_;
    int orientation_;
    uint32_t ui_flags_;
    uint32_t romsize_;
    uint32_t disp_tri_num_;
    uint32_t disp_seg_num_;
    uint32_t stl_tri_num_;
    bool draw_jumps_;
    bool auto_sync_;
    bool in_freertos_;
    bool rgb_;
    uint32_t stl_tri_mem_;
    uint32_t frame_ctr_;
    uint32_t app_dac_period_;
    uint32_t app_draw_steps_;
    uint32_t minx_;
    uint32_t miny_;
    uint32_t maxx_;
    uint32_t maxy_;
    int protocol_;
    int compressionlevel_;
    uint32_t move_steps_;
    bool stats_;
    int32_t x_offset_;
    int32_t y_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// -------------------------------------------------------------------

class Timer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.Timer) */ {
 public:
  inline Timer() : Timer(nullptr) {}
  ~Timer() override;
  explicit PROTOBUF_CONSTEXPR Timer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timer(const Timer& from);
  Timer(Timer&& from) noexcept
    : Timer() {
    *this = ::std::move(from);
  }

  inline Timer& operator=(const Timer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timer& operator=(Timer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timer* internal_default_instance() {
    return reinterpret_cast<const Timer*>(
               &_Timer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Timer& a, Timer& b) {
    a.Swap(&b);
  }
  inline void Swap(Timer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Timer& from) {
    Timer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.Timer";
  }
  protected:
  explicit Timer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kStampFieldNumber = 1,
    kPtimeFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 stamp = 1;
  void clear_stamp();
  uint32_t stamp() const;
  void set_stamp(uint32_t value);
  private:
  uint32_t _internal_stamp() const;
  void _internal_set_stamp(uint32_t value);
  public:

  // uint32 ptime = 2;
  void clear_ptime();
  uint32_t ptime() const;
  void set_ptime(uint32_t value);
  private:
  uint32_t _internal_ptime() const;
  void _internal_set_ptime(uint32_t value);
  public:

  // uint32 time = 3;
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.Timer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t stamp_;
    uint32_t ptime_;
    uint32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// -------------------------------------------------------------------

class Fps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.Fps) */ {
 public:
  inline Fps() : Fps(nullptr) {}
  ~Fps() override;
  explicit PROTOBUF_CONSTEXPR Fps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fps(const Fps& from);
  Fps(Fps&& from) noexcept
    : Fps() {
    *this = ::std::move(from);
  }

  inline Fps& operator=(const Fps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fps& operator=(Fps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fps* internal_default_instance() {
    return reinterpret_cast<const Fps*>(
               &_Fps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Fps& a, Fps& b) {
    a.Swap(&b);
  }
  inline void Swap(Fps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fps& from) {
    Fps::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.Fps";
  }
  protected:
  explicit Fps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFpsFieldNumber = 1,
    kMstartFieldNumber = 2,
    kMendFieldNumber = 3,
    kOverflowedFieldNumber = 4,
  };
  // double fps = 1;
  void clear_fps();
  double fps() const;
  void set_fps(double value);
  private:
  double _internal_fps() const;
  void _internal_set_fps(double value);
  public:

  // uint32 mstart = 2;
  void clear_mstart();
  uint32_t mstart() const;
  void set_mstart(uint32_t value);
  private:
  uint32_t _internal_mstart() const;
  void _internal_set_mstart(uint32_t value);
  public:

  // uint32 mend = 3;
  void clear_mend();
  uint32_t mend() const;
  void set_mend(uint32_t value);
  private:
  uint32_t _internal_mend() const;
  void _internal_set_mend(uint32_t value);
  public:

  // bool overflowed = 4;
  void clear_overflowed();
  bool overflowed() const;
  void set_overflowed(bool value);
  private:
  bool _internal_overflowed() const;
  void _internal_set_overflowed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.Fps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double fps_;
    uint32_t mstart_;
    uint32_t mend_;
    bool overflowed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// -------------------------------------------------------------------

class Stats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.Stats) */ {
 public:
  inline Stats() : Stats(nullptr) {}
  ~Stats() override;
  explicit PROTOBUF_CONSTEXPR Stats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stats(const Stats& from);
  Stats(Stats&& from) noexcept
    : Stats() {
    *this = ::std::move(from);
  }

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stats& operator=(Stats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stats& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stats* internal_default_instance() {
    return reinterpret_cast<const Stats*>(
               &_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Stats& a, Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(Stats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Stats& from) {
    Stats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.Stats";
  }
  protected:
  explicit Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPTimerFieldNumber = 5,
    kFpsTimerFieldNumber = 1,
    kInkFieldNumber = 3,
    kNoInkFieldNumber = 4,
    kOverflowedFieldNumber = 2,
    kFrameComplexityFieldNumber = 6,
  };
  // repeated .m_st.Timer p_timer = 5;
  int p_timer_size() const;
  private:
  int _internal_p_timer_size() const;
  public:
  void clear_p_timer();
  ::m_st::Timer* mutable_p_timer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::m_st::Timer >*
      mutable_p_timer();
  private:
  const ::m_st::Timer& _internal_p_timer(int index) const;
  ::m_st::Timer* _internal_add_p_timer();
  public:
  const ::m_st::Timer& p_timer(int index) const;
  ::m_st::Timer* add_p_timer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::m_st::Timer >&
      p_timer() const;

  // .m_st.Fps fps_timer = 1;
  bool has_fps_timer() const;
  private:
  bool _internal_has_fps_timer() const;
  public:
  void clear_fps_timer();
  const ::m_st::Fps& fps_timer() const;
  PROTOBUF_NODISCARD ::m_st::Fps* release_fps_timer();
  ::m_st::Fps* mutable_fps_timer();
  void set_allocated_fps_timer(::m_st::Fps* fps_timer);
  private:
  const ::m_st::Fps& _internal_fps_timer() const;
  ::m_st::Fps* _internal_mutable_fps_timer();
  public:
  void unsafe_arena_set_allocated_fps_timer(
      ::m_st::Fps* fps_timer);
  ::m_st::Fps* unsafe_arena_release_fps_timer();

  // double ink = 3;
  void clear_ink();
  double ink() const;
  void set_ink(double value);
  private:
  double _internal_ink() const;
  void _internal_set_ink(double value);
  public:

  // double no_ink = 4;
  void clear_no_ink();
  double no_ink() const;
  void set_no_ink(double value);
  private:
  double _internal_no_ink() const;
  void _internal_set_no_ink(double value);
  public:

  // bool overflowed = 2;
  void clear_overflowed();
  bool overflowed() const;
  void set_overflowed(bool value);
  private:
  bool _internal_overflowed() const;
  void _internal_set_overflowed(bool value);
  public:

  // uint32 frame_complexity = 6;
  void clear_frame_complexity();
  uint32_t frame_complexity() const;
  void set_frame_complexity(uint32_t value);
  private:
  uint32_t _internal_frame_complexity() const;
  void _internal_set_frame_complexity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::m_st::Timer > p_timer_;
    ::m_st::Fps* fps_timer_;
    double ink_;
    double no_ink_;
    bool overflowed_;
    uint32_t frame_complexity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// -------------------------------------------------------------------

class messageSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:m_st.messageSettings) */ {
 public:
  inline messageSettings() : messageSettings(nullptr) {}
  ~messageSettings() override;
  explicit PROTOBUF_CONSTEXPR messageSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  messageSettings(const messageSettings& from);
  messageSettings(messageSettings&& from) noexcept
    : messageSettings() {
    *this = ::std::move(from);
  }

  inline messageSettings& operator=(const messageSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline messageSettings& operator=(messageSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const messageSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const messageSettings* internal_default_instance() {
    return reinterpret_cast<const messageSettings*>(
               &_messageSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(messageSettings& a, messageSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(messageSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(messageSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  messageSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<messageSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const messageSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const messageSettings& from) {
    messageSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(messageSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "m_st.messageSettings";
  }
  protected:
  explicit messageSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSettingsFieldNumber = 3,
    kStatsFieldNumber = 5,
    kModeFieldNumber = 2,
    kTimerIdxFieldNumber = 4,
    kSpecScaleFieldNumber = 6,
    kBufferSizeOverrideFieldNumber = 7,
    kFontTypeFieldNumber = 8,
    kPageFieldNumber = 9,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .m_st.Settings settings = 3;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::m_st::Settings& settings() const;
  PROTOBUF_NODISCARD ::m_st::Settings* release_settings();
  ::m_st::Settings* mutable_settings();
  void set_allocated_settings(::m_st::Settings* settings);
  private:
  const ::m_st::Settings& _internal_settings() const;
  ::m_st::Settings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::m_st::Settings* settings);
  ::m_st::Settings* unsafe_arena_release_settings();

  // .m_st.Stats stats = 5;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::m_st::Stats& stats() const;
  PROTOBUF_NODISCARD ::m_st::Stats* release_stats();
  ::m_st::Stats* mutable_stats();
  void set_allocated_stats(::m_st::Stats* stats);
  private:
  const ::m_st::Stats& _internal_stats() const;
  ::m_st::Stats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::m_st::Stats* stats);
  ::m_st::Stats* unsafe_arena_release_stats();

  // .m_st.Mode mode = 2;
  void clear_mode();
  ::m_st::Mode mode() const;
  void set_mode(::m_st::Mode value);
  private:
  ::m_st::Mode _internal_mode() const;
  void _internal_set_mode(::m_st::Mode value);
  public:

  // uint32 timer_idx = 4;
  void clear_timer_idx();
  uint32_t timer_idx() const;
  void set_timer_idx(uint32_t value);
  private:
  uint32_t _internal_timer_idx() const;
  void _internal_set_timer_idx(uint32_t value);
  public:

  // float spec_scale = 6;
  void clear_spec_scale();
  float spec_scale() const;
  void set_spec_scale(float value);
  private:
  float _internal_spec_scale() const;
  void _internal_set_spec_scale(float value);
  public:

  // uint32 buffer_size_override = 7;
  void clear_buffer_size_override();
  uint32_t buffer_size_override() const;
  void set_buffer_size_override(uint32_t value);
  private:
  uint32_t _internal_buffer_size_override() const;
  void _internal_set_buffer_size_override(uint32_t value);
  public:

  // .m_st.Font font_type = 8;
  void clear_font_type();
  ::m_st::Font font_type() const;
  void set_font_type(::m_st::Font value);
  private:
  ::m_st::Font _internal_font_type() const;
  void _internal_set_font_type(::m_st::Font value);
  public:

  // .m_st.Pagetype page = 9;
  void clear_page();
  ::m_st::Pagetype page() const;
  void set_page(::m_st::Pagetype value);
  private:
  ::m_st::Pagetype _internal_page() const;
  void _internal_set_page(::m_st::Pagetype value);
  public:

  // @@protoc_insertion_point(class_scope:m_st.messageSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::m_st::Settings* settings_;
    ::m_st::Stats* stats_;
    int mode_;
    uint32_t timer_idx_;
    float spec_scale_;
    uint32_t buffer_size_override_;
    int font_type_;
    int page_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ui_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TextPos

// uint32 y = 1;
inline void TextPos::clear_y() {
  _impl_.y_ = 0u;
}
inline uint32_t TextPos::_internal_y() const {
  return _impl_.y_;
}
inline uint32_t TextPos::y() const {
  // @@protoc_insertion_point(field_get:m_st.TextPos.y)
  return _internal_y();
}
inline void TextPos::_internal_set_y(uint32_t value) {
  
  _impl_.y_ = value;
}
inline void TextPos::set_y(uint32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:m_st.TextPos.y)
}

// uint32 x = 2;
inline void TextPos::clear_x() {
  _impl_.x_ = 0u;
}
inline uint32_t TextPos::_internal_x() const {
  return _impl_.x_;
}
inline uint32_t TextPos::x() const {
  // @@protoc_insertion_point(field_get:m_st.TextPos.x)
  return _internal_x();
}
inline void TextPos::_internal_set_x(uint32_t value) {
  
  _impl_.x_ = value;
}
inline void TextPos::set_x(uint32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:m_st.TextPos.x)
}

// -------------------------------------------------------------------

// Settings

// uint32 dac_period = 1;
inline void Settings::clear_dac_period() {
  _impl_.dac_period_ = 0u;
}
inline uint32_t Settings::_internal_dac_period() const {
  return _impl_.dac_period_;
}
inline uint32_t Settings::dac_period() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.dac_period)
  return _internal_dac_period();
}
inline void Settings::_internal_set_dac_period(uint32_t value) {
  
  _impl_.dac_period_ = value;
}
inline void Settings::set_dac_period(uint32_t value) {
  _internal_set_dac_period(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.dac_period)
}

// uint32 draw_steps = 2;
inline void Settings::clear_draw_steps() {
  _impl_.draw_steps_ = 0u;
}
inline uint32_t Settings::_internal_draw_steps() const {
  return _impl_.draw_steps_;
}
inline uint32_t Settings::draw_steps() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.draw_steps)
  return _internal_draw_steps();
}
inline void Settings::_internal_set_draw_steps(uint32_t value) {
  
  _impl_.draw_steps_ = value;
}
inline void Settings::set_draw_steps(uint32_t value) {
  _internal_set_draw_steps(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.draw_steps)
}

// uint32 dwell = 3;
inline void Settings::clear_dwell() {
  _impl_.dwell_ = 0u;
}
inline uint32_t Settings::_internal_dwell() const {
  return _impl_.dwell_;
}
inline uint32_t Settings::dwell() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.dwell)
  return _internal_dwell();
}
inline void Settings::_internal_set_dwell(uint32_t value) {
  
  _impl_.dwell_ = value;
}
inline void Settings::set_dwell(uint32_t value) {
  _internal_set_dwell(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.dwell)
}

// bool fine_type = 4;
inline void Settings::clear_fine_type() {
  _impl_.fine_type_ = false;
}
inline bool Settings::_internal_fine_type() const {
  return _impl_.fine_type_;
}
inline bool Settings::fine_type() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.fine_type)
  return _internal_fine_type();
}
inline void Settings::_internal_set_fine_type(bool value) {
  
  _impl_.fine_type_ = value;
}
inline void Settings::set_fine_type(bool value) {
  _internal_set_fine_type(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.fine_type)
}

// bool controllers = 5;
inline void Settings::clear_controllers() {
  _impl_.controllers_ = false;
}
inline bool Settings::_internal_controllers() const {
  return _impl_.controllers_;
}
inline bool Settings::controllers() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.controllers)
  return _internal_controllers();
}
inline void Settings::_internal_set_controllers(bool value) {
  
  _impl_.controllers_ = value;
}
inline void Settings::set_controllers(bool value) {
  _internal_set_controllers(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.controllers)
}

// bool lcd = 6;
inline void Settings::clear_lcd() {
  _impl_.lcd_ = false;
}
inline bool Settings::_internal_lcd() const {
  return _impl_.lcd_;
}
inline bool Settings::lcd() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.lcd)
  return _internal_lcd();
}
inline void Settings::_internal_set_lcd(bool value) {
  
  _impl_.lcd_ = value;
}
inline void Settings::set_lcd(bool value) {
  _internal_set_lcd(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.lcd)
}

// bool audio = 7;
inline void Settings::clear_audio() {
  _impl_.audio_ = false;
}
inline bool Settings::_internal_audio() const {
  return _impl_.audio_;
}
inline bool Settings::audio() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.audio)
  return _internal_audio();
}
inline void Settings::_internal_set_audio(bool value) {
  
  _impl_.audio_ = value;
}
inline void Settings::set_audio(bool value) {
  _internal_set_audio(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.audio)
}

// bool draw_jumps = 8;
inline void Settings::clear_draw_jumps() {
  _impl_.draw_jumps_ = false;
}
inline bool Settings::_internal_draw_jumps() const {
  return _impl_.draw_jumps_;
}
inline bool Settings::draw_jumps() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.draw_jumps)
  return _internal_draw_jumps();
}
inline void Settings::_internal_set_draw_jumps(bool value) {
  
  _impl_.draw_jumps_ = value;
}
inline void Settings::set_draw_jumps(bool value) {
  _internal_set_draw_jumps(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.draw_jumps)
}

// bool auto_sync = 9;
inline void Settings::clear_auto_sync() {
  _impl_.auto_sync_ = false;
}
inline bool Settings::_internal_auto_sync() const {
  return _impl_.auto_sync_;
}
inline bool Settings::auto_sync() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.auto_sync)
  return _internal_auto_sync();
}
inline void Settings::_internal_set_auto_sync(bool value) {
  
  _impl_.auto_sync_ = value;
}
inline void Settings::set_auto_sync(bool value) {
  _internal_set_auto_sync(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.auto_sync)
}

// .m_st.BufferMode buffer_mode = 10;
inline void Settings::clear_buffer_mode() {
  _impl_.buffer_mode_ = 0;
}
inline ::m_st::BufferMode Settings::_internal_buffer_mode() const {
  return static_cast< ::m_st::BufferMode >(_impl_.buffer_mode_);
}
inline ::m_st::BufferMode Settings::buffer_mode() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.buffer_mode)
  return _internal_buffer_mode();
}
inline void Settings::_internal_set_buffer_mode(::m_st::BufferMode value) {
  
  _impl_.buffer_mode_ = value;
}
inline void Settings::set_buffer_mode(::m_st::BufferMode value) {
  _internal_set_buffer_mode(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.buffer_mode)
}

// .m_st.BufferType buffer_type = 11;
inline void Settings::clear_buffer_type() {
  _impl_.buffer_type_ = 0;
}
inline ::m_st::BufferType Settings::_internal_buffer_type() const {
  return static_cast< ::m_st::BufferType >(_impl_.buffer_type_);
}
inline ::m_st::BufferType Settings::buffer_type() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.buffer_type)
  return _internal_buffer_type();
}
inline void Settings::_internal_set_buffer_type(::m_st::BufferType value) {
  
  _impl_.buffer_type_ = value;
}
inline void Settings::set_buffer_type(::m_st::BufferType value) {
  _internal_set_buffer_type(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.buffer_type)
}

// uint32 scalex = 12;
inline void Settings::clear_scalex() {
  _impl_.scalex_ = 0u;
}
inline uint32_t Settings::_internal_scalex() const {
  return _impl_.scalex_;
}
inline uint32_t Settings::scalex() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.scalex)
  return _internal_scalex();
}
inline void Settings::_internal_set_scalex(uint32_t value) {
  
  _impl_.scalex_ = value;
}
inline void Settings::set_scalex(uint32_t value) {
  _internal_set_scalex(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.scalex)
}

// uint32 scaley = 13;
inline void Settings::clear_scaley() {
  _impl_.scaley_ = 0u;
}
inline uint32_t Settings::_internal_scaley() const {
  return _impl_.scaley_;
}
inline uint32_t Settings::scaley() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.scaley)
  return _internal_scaley();
}
inline void Settings::_internal_set_scaley(uint32_t value) {
  
  _impl_.scaley_ = value;
}
inline void Settings::set_scaley(uint32_t value) {
  _internal_set_scaley(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.scaley)
}

// .m_st.Orientation orientation = 14;
inline void Settings::clear_orientation() {
  _impl_.orientation_ = 0;
}
inline ::m_st::Orientation Settings::_internal_orientation() const {
  return static_cast< ::m_st::Orientation >(_impl_.orientation_);
}
inline ::m_st::Orientation Settings::orientation() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.orientation)
  return _internal_orientation();
}
inline void Settings::_internal_set_orientation(::m_st::Orientation value) {
  
  _impl_.orientation_ = value;
}
inline void Settings::set_orientation(::m_st::Orientation value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.orientation)
}

// uint32 ui_flags = 15;
inline void Settings::clear_ui_flags() {
  _impl_.ui_flags_ = 0u;
}
inline uint32_t Settings::_internal_ui_flags() const {
  return _impl_.ui_flags_;
}
inline uint32_t Settings::ui_flags() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.ui_flags)
  return _internal_ui_flags();
}
inline void Settings::_internal_set_ui_flags(uint32_t value) {
  
  _impl_.ui_flags_ = value;
}
inline void Settings::set_ui_flags(uint32_t value) {
  _internal_set_ui_flags(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.ui_flags)
}

// uint32 romsize = 16;
inline void Settings::clear_romsize() {
  _impl_.romsize_ = 0u;
}
inline uint32_t Settings::_internal_romsize() const {
  return _impl_.romsize_;
}
inline uint32_t Settings::romsize() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.romsize)
  return _internal_romsize();
}
inline void Settings::_internal_set_romsize(uint32_t value) {
  
  _impl_.romsize_ = value;
}
inline void Settings::set_romsize(uint32_t value) {
  _internal_set_romsize(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.romsize)
}

// uint32 disp_tri_num = 17;
inline void Settings::clear_disp_tri_num() {
  _impl_.disp_tri_num_ = 0u;
}
inline uint32_t Settings::_internal_disp_tri_num() const {
  return _impl_.disp_tri_num_;
}
inline uint32_t Settings::disp_tri_num() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.disp_tri_num)
  return _internal_disp_tri_num();
}
inline void Settings::_internal_set_disp_tri_num(uint32_t value) {
  
  _impl_.disp_tri_num_ = value;
}
inline void Settings::set_disp_tri_num(uint32_t value) {
  _internal_set_disp_tri_num(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.disp_tri_num)
}

// uint32 disp_seg_num = 18;
inline void Settings::clear_disp_seg_num() {
  _impl_.disp_seg_num_ = 0u;
}
inline uint32_t Settings::_internal_disp_seg_num() const {
  return _impl_.disp_seg_num_;
}
inline uint32_t Settings::disp_seg_num() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.disp_seg_num)
  return _internal_disp_seg_num();
}
inline void Settings::_internal_set_disp_seg_num(uint32_t value) {
  
  _impl_.disp_seg_num_ = value;
}
inline void Settings::set_disp_seg_num(uint32_t value) {
  _internal_set_disp_seg_num(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.disp_seg_num)
}

// uint32 stl_tri_num = 19;
inline void Settings::clear_stl_tri_num() {
  _impl_.stl_tri_num_ = 0u;
}
inline uint32_t Settings::_internal_stl_tri_num() const {
  return _impl_.stl_tri_num_;
}
inline uint32_t Settings::stl_tri_num() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.stl_tri_num)
  return _internal_stl_tri_num();
}
inline void Settings::_internal_set_stl_tri_num(uint32_t value) {
  
  _impl_.stl_tri_num_ = value;
}
inline void Settings::set_stl_tri_num(uint32_t value) {
  _internal_set_stl_tri_num(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.stl_tri_num)
}

// uint32 stl_tri_mem = 20;
inline void Settings::clear_stl_tri_mem() {
  _impl_.stl_tri_mem_ = 0u;
}
inline uint32_t Settings::_internal_stl_tri_mem() const {
  return _impl_.stl_tri_mem_;
}
inline uint32_t Settings::stl_tri_mem() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.stl_tri_mem)
  return _internal_stl_tri_mem();
}
inline void Settings::_internal_set_stl_tri_mem(uint32_t value) {
  
  _impl_.stl_tri_mem_ = value;
}
inline void Settings::set_stl_tri_mem(uint32_t value) {
  _internal_set_stl_tri_mem(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.stl_tri_mem)
}

// uint32 frame_ctr = 21;
inline void Settings::clear_frame_ctr() {
  _impl_.frame_ctr_ = 0u;
}
inline uint32_t Settings::_internal_frame_ctr() const {
  return _impl_.frame_ctr_;
}
inline uint32_t Settings::frame_ctr() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.frame_ctr)
  return _internal_frame_ctr();
}
inline void Settings::_internal_set_frame_ctr(uint32_t value) {
  
  _impl_.frame_ctr_ = value;
}
inline void Settings::set_frame_ctr(uint32_t value) {
  _internal_set_frame_ctr(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.frame_ctr)
}

// uint32 app_dac_period = 22;
inline void Settings::clear_app_dac_period() {
  _impl_.app_dac_period_ = 0u;
}
inline uint32_t Settings::_internal_app_dac_period() const {
  return _impl_.app_dac_period_;
}
inline uint32_t Settings::app_dac_period() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.app_dac_period)
  return _internal_app_dac_period();
}
inline void Settings::_internal_set_app_dac_period(uint32_t value) {
  
  _impl_.app_dac_period_ = value;
}
inline void Settings::set_app_dac_period(uint32_t value) {
  _internal_set_app_dac_period(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.app_dac_period)
}

// uint32 app_draw_steps = 23;
inline void Settings::clear_app_draw_steps() {
  _impl_.app_draw_steps_ = 0u;
}
inline uint32_t Settings::_internal_app_draw_steps() const {
  return _impl_.app_draw_steps_;
}
inline uint32_t Settings::app_draw_steps() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.app_draw_steps)
  return _internal_app_draw_steps();
}
inline void Settings::_internal_set_app_draw_steps(uint32_t value) {
  
  _impl_.app_draw_steps_ = value;
}
inline void Settings::set_app_draw_steps(uint32_t value) {
  _internal_set_app_draw_steps(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.app_draw_steps)
}

// uint32 minx = 24;
inline void Settings::clear_minx() {
  _impl_.minx_ = 0u;
}
inline uint32_t Settings::_internal_minx() const {
  return _impl_.minx_;
}
inline uint32_t Settings::minx() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.minx)
  return _internal_minx();
}
inline void Settings::_internal_set_minx(uint32_t value) {
  
  _impl_.minx_ = value;
}
inline void Settings::set_minx(uint32_t value) {
  _internal_set_minx(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.minx)
}

// uint32 miny = 25;
inline void Settings::clear_miny() {
  _impl_.miny_ = 0u;
}
inline uint32_t Settings::_internal_miny() const {
  return _impl_.miny_;
}
inline uint32_t Settings::miny() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.miny)
  return _internal_miny();
}
inline void Settings::_internal_set_miny(uint32_t value) {
  
  _impl_.miny_ = value;
}
inline void Settings::set_miny(uint32_t value) {
  _internal_set_miny(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.miny)
}

// uint32 maxx = 26;
inline void Settings::clear_maxx() {
  _impl_.maxx_ = 0u;
}
inline uint32_t Settings::_internal_maxx() const {
  return _impl_.maxx_;
}
inline uint32_t Settings::maxx() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.maxx)
  return _internal_maxx();
}
inline void Settings::_internal_set_maxx(uint32_t value) {
  
  _impl_.maxx_ = value;
}
inline void Settings::set_maxx(uint32_t value) {
  _internal_set_maxx(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.maxx)
}

// uint32 maxy = 27;
inline void Settings::clear_maxy() {
  _impl_.maxy_ = 0u;
}
inline uint32_t Settings::_internal_maxy() const {
  return _impl_.maxy_;
}
inline uint32_t Settings::maxy() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.maxy)
  return _internal_maxy();
}
inline void Settings::_internal_set_maxy(uint32_t value) {
  
  _impl_.maxy_ = value;
}
inline void Settings::set_maxy(uint32_t value) {
  _internal_set_maxy(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.maxy)
}

// bool in_freertos = 28;
inline void Settings::clear_in_freertos() {
  _impl_.in_freertos_ = false;
}
inline bool Settings::_internal_in_freertos() const {
  return _impl_.in_freertos_;
}
inline bool Settings::in_freertos() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.in_freertos)
  return _internal_in_freertos();
}
inline void Settings::_internal_set_in_freertos(bool value) {
  
  _impl_.in_freertos_ = value;
}
inline void Settings::set_in_freertos(bool value) {
  _internal_set_in_freertos(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.in_freertos)
}

// .m_st.Protocol protocol = 29;
inline void Settings::clear_protocol() {
  _impl_.protocol_ = 0;
}
inline ::m_st::Protocol Settings::_internal_protocol() const {
  return static_cast< ::m_st::Protocol >(_impl_.protocol_);
}
inline ::m_st::Protocol Settings::protocol() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.protocol)
  return _internal_protocol();
}
inline void Settings::_internal_set_protocol(::m_st::Protocol value) {
  
  _impl_.protocol_ = value;
}
inline void Settings::set_protocol(::m_st::Protocol value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.protocol)
}

// .m_st.compressionFlags compressionLevel = 30;
inline void Settings::clear_compressionlevel() {
  _impl_.compressionlevel_ = 0;
}
inline ::m_st::compressionFlags Settings::_internal_compressionlevel() const {
  return static_cast< ::m_st::compressionFlags >(_impl_.compressionlevel_);
}
inline ::m_st::compressionFlags Settings::compressionlevel() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.compressionLevel)
  return _internal_compressionlevel();
}
inline void Settings::_internal_set_compressionlevel(::m_st::compressionFlags value) {
  
  _impl_.compressionlevel_ = value;
}
inline void Settings::set_compressionlevel(::m_st::compressionFlags value) {
  _internal_set_compressionlevel(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.compressionLevel)
}

// bool rgb = 31;
inline void Settings::clear_rgb() {
  _impl_.rgb_ = false;
}
inline bool Settings::_internal_rgb() const {
  return _impl_.rgb_;
}
inline bool Settings::rgb() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.rgb)
  return _internal_rgb();
}
inline void Settings::_internal_set_rgb(bool value) {
  
  _impl_.rgb_ = value;
}
inline void Settings::set_rgb(bool value) {
  _internal_set_rgb(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.rgb)
}

// uint32 move_steps = 32;
inline void Settings::clear_move_steps() {
  _impl_.move_steps_ = 0u;
}
inline uint32_t Settings::_internal_move_steps() const {
  return _impl_.move_steps_;
}
inline uint32_t Settings::move_steps() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.move_steps)
  return _internal_move_steps();
}
inline void Settings::_internal_set_move_steps(uint32_t value) {
  
  _impl_.move_steps_ = value;
}
inline void Settings::set_move_steps(uint32_t value) {
  _internal_set_move_steps(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.move_steps)
}

// bool stats = 33;
inline void Settings::clear_stats() {
  _impl_.stats_ = false;
}
inline bool Settings::_internal_stats() const {
  return _impl_.stats_;
}
inline bool Settings::stats() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.stats)
  return _internal_stats();
}
inline void Settings::_internal_set_stats(bool value) {
  
  _impl_.stats_ = value;
}
inline void Settings::set_stats(bool value) {
  _internal_set_stats(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.stats)
}

// int32 x_offset = 34;
inline void Settings::clear_x_offset() {
  _impl_.x_offset_ = 0;
}
inline int32_t Settings::_internal_x_offset() const {
  return _impl_.x_offset_;
}
inline int32_t Settings::x_offset() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.x_offset)
  return _internal_x_offset();
}
inline void Settings::_internal_set_x_offset(int32_t value) {
  
  _impl_.x_offset_ = value;
}
inline void Settings::set_x_offset(int32_t value) {
  _internal_set_x_offset(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.x_offset)
}

// int32 y_offset = 35;
inline void Settings::clear_y_offset() {
  _impl_.y_offset_ = 0;
}
inline int32_t Settings::_internal_y_offset() const {
  return _impl_.y_offset_;
}
inline int32_t Settings::y_offset() const {
  // @@protoc_insertion_point(field_get:m_st.Settings.y_offset)
  return _internal_y_offset();
}
inline void Settings::_internal_set_y_offset(int32_t value) {
  
  _impl_.y_offset_ = value;
}
inline void Settings::set_y_offset(int32_t value) {
  _internal_set_y_offset(value);
  // @@protoc_insertion_point(field_set:m_st.Settings.y_offset)
}

// -------------------------------------------------------------------

// Timer

// uint32 stamp = 1;
inline void Timer::clear_stamp() {
  _impl_.stamp_ = 0u;
}
inline uint32_t Timer::_internal_stamp() const {
  return _impl_.stamp_;
}
inline uint32_t Timer::stamp() const {
  // @@protoc_insertion_point(field_get:m_st.Timer.stamp)
  return _internal_stamp();
}
inline void Timer::_internal_set_stamp(uint32_t value) {
  
  _impl_.stamp_ = value;
}
inline void Timer::set_stamp(uint32_t value) {
  _internal_set_stamp(value);
  // @@protoc_insertion_point(field_set:m_st.Timer.stamp)
}

// uint32 ptime = 2;
inline void Timer::clear_ptime() {
  _impl_.ptime_ = 0u;
}
inline uint32_t Timer::_internal_ptime() const {
  return _impl_.ptime_;
}
inline uint32_t Timer::ptime() const {
  // @@protoc_insertion_point(field_get:m_st.Timer.ptime)
  return _internal_ptime();
}
inline void Timer::_internal_set_ptime(uint32_t value) {
  
  _impl_.ptime_ = value;
}
inline void Timer::set_ptime(uint32_t value) {
  _internal_set_ptime(value);
  // @@protoc_insertion_point(field_set:m_st.Timer.ptime)
}

// uint32 time = 3;
inline void Timer::clear_time() {
  _impl_.time_ = 0u;
}
inline uint32_t Timer::_internal_time() const {
  return _impl_.time_;
}
inline uint32_t Timer::time() const {
  // @@protoc_insertion_point(field_get:m_st.Timer.time)
  return _internal_time();
}
inline void Timer::_internal_set_time(uint32_t value) {
  
  _impl_.time_ = value;
}
inline void Timer::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:m_st.Timer.time)
}

// string name = 4;
inline void Timer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Timer::name() const {
  // @@protoc_insertion_point(field_get:m_st.Timer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Timer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:m_st.Timer.name)
}
inline std::string* Timer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:m_st.Timer.name)
  return _s;
}
inline const std::string& Timer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Timer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Timer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Timer::release_name() {
  // @@protoc_insertion_point(field_release:m_st.Timer.name)
  return _impl_.name_.Release();
}
inline void Timer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:m_st.Timer.name)
}

// -------------------------------------------------------------------

// Fps

// double fps = 1;
inline void Fps::clear_fps() {
  _impl_.fps_ = 0;
}
inline double Fps::_internal_fps() const {
  return _impl_.fps_;
}
inline double Fps::fps() const {
  // @@protoc_insertion_point(field_get:m_st.Fps.fps)
  return _internal_fps();
}
inline void Fps::_internal_set_fps(double value) {
  
  _impl_.fps_ = value;
}
inline void Fps::set_fps(double value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:m_st.Fps.fps)
}

// uint32 mstart = 2;
inline void Fps::clear_mstart() {
  _impl_.mstart_ = 0u;
}
inline uint32_t Fps::_internal_mstart() const {
  return _impl_.mstart_;
}
inline uint32_t Fps::mstart() const {
  // @@protoc_insertion_point(field_get:m_st.Fps.mstart)
  return _internal_mstart();
}
inline void Fps::_internal_set_mstart(uint32_t value) {
  
  _impl_.mstart_ = value;
}
inline void Fps::set_mstart(uint32_t value) {
  _internal_set_mstart(value);
  // @@protoc_insertion_point(field_set:m_st.Fps.mstart)
}

// uint32 mend = 3;
inline void Fps::clear_mend() {
  _impl_.mend_ = 0u;
}
inline uint32_t Fps::_internal_mend() const {
  return _impl_.mend_;
}
inline uint32_t Fps::mend() const {
  // @@protoc_insertion_point(field_get:m_st.Fps.mend)
  return _internal_mend();
}
inline void Fps::_internal_set_mend(uint32_t value) {
  
  _impl_.mend_ = value;
}
inline void Fps::set_mend(uint32_t value) {
  _internal_set_mend(value);
  // @@protoc_insertion_point(field_set:m_st.Fps.mend)
}

// bool overflowed = 4;
inline void Fps::clear_overflowed() {
  _impl_.overflowed_ = false;
}
inline bool Fps::_internal_overflowed() const {
  return _impl_.overflowed_;
}
inline bool Fps::overflowed() const {
  // @@protoc_insertion_point(field_get:m_st.Fps.overflowed)
  return _internal_overflowed();
}
inline void Fps::_internal_set_overflowed(bool value) {
  
  _impl_.overflowed_ = value;
}
inline void Fps::set_overflowed(bool value) {
  _internal_set_overflowed(value);
  // @@protoc_insertion_point(field_set:m_st.Fps.overflowed)
}

// -------------------------------------------------------------------

// Stats

// .m_st.Fps fps_timer = 1;
inline bool Stats::_internal_has_fps_timer() const {
  return this != internal_default_instance() && _impl_.fps_timer_ != nullptr;
}
inline bool Stats::has_fps_timer() const {
  return _internal_has_fps_timer();
}
inline void Stats::clear_fps_timer() {
  if (GetArenaForAllocation() == nullptr && _impl_.fps_timer_ != nullptr) {
    delete _impl_.fps_timer_;
  }
  _impl_.fps_timer_ = nullptr;
}
inline const ::m_st::Fps& Stats::_internal_fps_timer() const {
  const ::m_st::Fps* p = _impl_.fps_timer_;
  return p != nullptr ? *p : reinterpret_cast<const ::m_st::Fps&>(
      ::m_st::_Fps_default_instance_);
}
inline const ::m_st::Fps& Stats::fps_timer() const {
  // @@protoc_insertion_point(field_get:m_st.Stats.fps_timer)
  return _internal_fps_timer();
}
inline void Stats::unsafe_arena_set_allocated_fps_timer(
    ::m_st::Fps* fps_timer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fps_timer_);
  }
  _impl_.fps_timer_ = fps_timer;
  if (fps_timer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:m_st.Stats.fps_timer)
}
inline ::m_st::Fps* Stats::release_fps_timer() {
  
  ::m_st::Fps* temp = _impl_.fps_timer_;
  _impl_.fps_timer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::m_st::Fps* Stats::unsafe_arena_release_fps_timer() {
  // @@protoc_insertion_point(field_release:m_st.Stats.fps_timer)
  
  ::m_st::Fps* temp = _impl_.fps_timer_;
  _impl_.fps_timer_ = nullptr;
  return temp;
}
inline ::m_st::Fps* Stats::_internal_mutable_fps_timer() {
  
  if (_impl_.fps_timer_ == nullptr) {
    auto* p = CreateMaybeMessage<::m_st::Fps>(GetArenaForAllocation());
    _impl_.fps_timer_ = p;
  }
  return _impl_.fps_timer_;
}
inline ::m_st::Fps* Stats::mutable_fps_timer() {
  ::m_st::Fps* _msg = _internal_mutable_fps_timer();
  // @@protoc_insertion_point(field_mutable:m_st.Stats.fps_timer)
  return _msg;
}
inline void Stats::set_allocated_fps_timer(::m_st::Fps* fps_timer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fps_timer_;
  }
  if (fps_timer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fps_timer);
    if (message_arena != submessage_arena) {
      fps_timer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fps_timer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fps_timer_ = fps_timer;
  // @@protoc_insertion_point(field_set_allocated:m_st.Stats.fps_timer)
}

// bool overflowed = 2;
inline void Stats::clear_overflowed() {
  _impl_.overflowed_ = false;
}
inline bool Stats::_internal_overflowed() const {
  return _impl_.overflowed_;
}
inline bool Stats::overflowed() const {
  // @@protoc_insertion_point(field_get:m_st.Stats.overflowed)
  return _internal_overflowed();
}
inline void Stats::_internal_set_overflowed(bool value) {
  
  _impl_.overflowed_ = value;
}
inline void Stats::set_overflowed(bool value) {
  _internal_set_overflowed(value);
  // @@protoc_insertion_point(field_set:m_st.Stats.overflowed)
}

// double ink = 3;
inline void Stats::clear_ink() {
  _impl_.ink_ = 0;
}
inline double Stats::_internal_ink() const {
  return _impl_.ink_;
}
inline double Stats::ink() const {
  // @@protoc_insertion_point(field_get:m_st.Stats.ink)
  return _internal_ink();
}
inline void Stats::_internal_set_ink(double value) {
  
  _impl_.ink_ = value;
}
inline void Stats::set_ink(double value) {
  _internal_set_ink(value);
  // @@protoc_insertion_point(field_set:m_st.Stats.ink)
}

// double no_ink = 4;
inline void Stats::clear_no_ink() {
  _impl_.no_ink_ = 0;
}
inline double Stats::_internal_no_ink() const {
  return _impl_.no_ink_;
}
inline double Stats::no_ink() const {
  // @@protoc_insertion_point(field_get:m_st.Stats.no_ink)
  return _internal_no_ink();
}
inline void Stats::_internal_set_no_ink(double value) {
  
  _impl_.no_ink_ = value;
}
inline void Stats::set_no_ink(double value) {
  _internal_set_no_ink(value);
  // @@protoc_insertion_point(field_set:m_st.Stats.no_ink)
}

// repeated .m_st.Timer p_timer = 5;
inline int Stats::_internal_p_timer_size() const {
  return _impl_.p_timer_.size();
}
inline int Stats::p_timer_size() const {
  return _internal_p_timer_size();
}
inline void Stats::clear_p_timer() {
  _impl_.p_timer_.Clear();
}
inline ::m_st::Timer* Stats::mutable_p_timer(int index) {
  // @@protoc_insertion_point(field_mutable:m_st.Stats.p_timer)
  return _impl_.p_timer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::m_st::Timer >*
Stats::mutable_p_timer() {
  // @@protoc_insertion_point(field_mutable_list:m_st.Stats.p_timer)
  return &_impl_.p_timer_;
}
inline const ::m_st::Timer& Stats::_internal_p_timer(int index) const {
  return _impl_.p_timer_.Get(index);
}
inline const ::m_st::Timer& Stats::p_timer(int index) const {
  // @@protoc_insertion_point(field_get:m_st.Stats.p_timer)
  return _internal_p_timer(index);
}
inline ::m_st::Timer* Stats::_internal_add_p_timer() {
  return _impl_.p_timer_.Add();
}
inline ::m_st::Timer* Stats::add_p_timer() {
  ::m_st::Timer* _add = _internal_add_p_timer();
  // @@protoc_insertion_point(field_add:m_st.Stats.p_timer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::m_st::Timer >&
Stats::p_timer() const {
  // @@protoc_insertion_point(field_list:m_st.Stats.p_timer)
  return _impl_.p_timer_;
}

// uint32 frame_complexity = 6;
inline void Stats::clear_frame_complexity() {
  _impl_.frame_complexity_ = 0u;
}
inline uint32_t Stats::_internal_frame_complexity() const {
  return _impl_.frame_complexity_;
}
inline uint32_t Stats::frame_complexity() const {
  // @@protoc_insertion_point(field_get:m_st.Stats.frame_complexity)
  return _internal_frame_complexity();
}
inline void Stats::_internal_set_frame_complexity(uint32_t value) {
  
  _impl_.frame_complexity_ = value;
}
inline void Stats::set_frame_complexity(uint32_t value) {
  _internal_set_frame_complexity(value);
  // @@protoc_insertion_point(field_set:m_st.Stats.frame_complexity)
}

// -------------------------------------------------------------------

// messageSettings

// string name = 1;
inline void messageSettings::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& messageSettings::name() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void messageSettings::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:m_st.messageSettings.name)
}
inline std::string* messageSettings::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:m_st.messageSettings.name)
  return _s;
}
inline const std::string& messageSettings::_internal_name() const {
  return _impl_.name_.Get();
}
inline void messageSettings::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* messageSettings::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* messageSettings::release_name() {
  // @@protoc_insertion_point(field_release:m_st.messageSettings.name)
  return _impl_.name_.Release();
}
inline void messageSettings::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:m_st.messageSettings.name)
}

// .m_st.Mode mode = 2;
inline void messageSettings::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::m_st::Mode messageSettings::_internal_mode() const {
  return static_cast< ::m_st::Mode >(_impl_.mode_);
}
inline ::m_st::Mode messageSettings::mode() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.mode)
  return _internal_mode();
}
inline void messageSettings::_internal_set_mode(::m_st::Mode value) {
  
  _impl_.mode_ = value;
}
inline void messageSettings::set_mode(::m_st::Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.mode)
}

// .m_st.Settings settings = 3;
inline bool messageSettings::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool messageSettings::has_settings() const {
  return _internal_has_settings();
}
inline void messageSettings::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::m_st::Settings& messageSettings::_internal_settings() const {
  const ::m_st::Settings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::m_st::Settings&>(
      ::m_st::_Settings_default_instance_);
}
inline const ::m_st::Settings& messageSettings::settings() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.settings)
  return _internal_settings();
}
inline void messageSettings::unsafe_arena_set_allocated_settings(
    ::m_st::Settings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:m_st.messageSettings.settings)
}
inline ::m_st::Settings* messageSettings::release_settings() {
  
  ::m_st::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::m_st::Settings* messageSettings::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:m_st.messageSettings.settings)
  
  ::m_st::Settings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::m_st::Settings* messageSettings::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::m_st::Settings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::m_st::Settings* messageSettings::mutable_settings() {
  ::m_st::Settings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:m_st.messageSettings.settings)
  return _msg;
}
inline void messageSettings::set_allocated_settings(::m_st::Settings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:m_st.messageSettings.settings)
}

// uint32 timer_idx = 4;
inline void messageSettings::clear_timer_idx() {
  _impl_.timer_idx_ = 0u;
}
inline uint32_t messageSettings::_internal_timer_idx() const {
  return _impl_.timer_idx_;
}
inline uint32_t messageSettings::timer_idx() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.timer_idx)
  return _internal_timer_idx();
}
inline void messageSettings::_internal_set_timer_idx(uint32_t value) {
  
  _impl_.timer_idx_ = value;
}
inline void messageSettings::set_timer_idx(uint32_t value) {
  _internal_set_timer_idx(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.timer_idx)
}

// .m_st.Stats stats = 5;
inline bool messageSettings::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool messageSettings::has_stats() const {
  return _internal_has_stats();
}
inline void messageSettings::clear_stats() {
  if (GetArenaForAllocation() == nullptr && _impl_.stats_ != nullptr) {
    delete _impl_.stats_;
  }
  _impl_.stats_ = nullptr;
}
inline const ::m_st::Stats& messageSettings::_internal_stats() const {
  const ::m_st::Stats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::m_st::Stats&>(
      ::m_st::_Stats_default_instance_);
}
inline const ::m_st::Stats& messageSettings::stats() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.stats)
  return _internal_stats();
}
inline void messageSettings::unsafe_arena_set_allocated_stats(
    ::m_st::Stats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:m_st.messageSettings.stats)
}
inline ::m_st::Stats* messageSettings::release_stats() {
  
  ::m_st::Stats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::m_st::Stats* messageSettings::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:m_st.messageSettings.stats)
  
  ::m_st::Stats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::m_st::Stats* messageSettings::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::m_st::Stats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::m_st::Stats* messageSettings::mutable_stats() {
  ::m_st::Stats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:m_st.messageSettings.stats)
  return _msg;
}
inline void messageSettings::set_allocated_stats(::m_st::Stats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:m_st.messageSettings.stats)
}

// float spec_scale = 6;
inline void messageSettings::clear_spec_scale() {
  _impl_.spec_scale_ = 0;
}
inline float messageSettings::_internal_spec_scale() const {
  return _impl_.spec_scale_;
}
inline float messageSettings::spec_scale() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.spec_scale)
  return _internal_spec_scale();
}
inline void messageSettings::_internal_set_spec_scale(float value) {
  
  _impl_.spec_scale_ = value;
}
inline void messageSettings::set_spec_scale(float value) {
  _internal_set_spec_scale(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.spec_scale)
}

// uint32 buffer_size_override = 7;
inline void messageSettings::clear_buffer_size_override() {
  _impl_.buffer_size_override_ = 0u;
}
inline uint32_t messageSettings::_internal_buffer_size_override() const {
  return _impl_.buffer_size_override_;
}
inline uint32_t messageSettings::buffer_size_override() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.buffer_size_override)
  return _internal_buffer_size_override();
}
inline void messageSettings::_internal_set_buffer_size_override(uint32_t value) {
  
  _impl_.buffer_size_override_ = value;
}
inline void messageSettings::set_buffer_size_override(uint32_t value) {
  _internal_set_buffer_size_override(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.buffer_size_override)
}

// .m_st.Font font_type = 8;
inline void messageSettings::clear_font_type() {
  _impl_.font_type_ = 0;
}
inline ::m_st::Font messageSettings::_internal_font_type() const {
  return static_cast< ::m_st::Font >(_impl_.font_type_);
}
inline ::m_st::Font messageSettings::font_type() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.font_type)
  return _internal_font_type();
}
inline void messageSettings::_internal_set_font_type(::m_st::Font value) {
  
  _impl_.font_type_ = value;
}
inline void messageSettings::set_font_type(::m_st::Font value) {
  _internal_set_font_type(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.font_type)
}

// .m_st.Pagetype page = 9;
inline void messageSettings::clear_page() {
  _impl_.page_ = 0;
}
inline ::m_st::Pagetype messageSettings::_internal_page() const {
  return static_cast< ::m_st::Pagetype >(_impl_.page_);
}
inline ::m_st::Pagetype messageSettings::page() const {
  // @@protoc_insertion_point(field_get:m_st.messageSettings.page)
  return _internal_page();
}
inline void messageSettings::_internal_set_page(::m_st::Pagetype value) {
  
  _impl_.page_ = value;
}
inline void messageSettings::set_page(::m_st::Pagetype value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:m_st.messageSettings.page)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace m_st

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::m_st::Protocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::Protocol>() {
  return ::m_st::Protocol_descriptor();
}
template <> struct is_proto_enum< ::m_st::Orientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::Orientation>() {
  return ::m_st::Orientation_descriptor();
}
template <> struct is_proto_enum< ::m_st::BufferMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::BufferMode>() {
  return ::m_st::BufferMode_descriptor();
}
template <> struct is_proto_enum< ::m_st::Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::Mode>() {
  return ::m_st::Mode_descriptor();
}
template <> struct is_proto_enum< ::m_st::compressionFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::compressionFlags>() {
  return ::m_st::compressionFlags_descriptor();
}
template <> struct is_proto_enum< ::m_st::uiFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::uiFlags>() {
  return ::m_st::uiFlags_descriptor();
}
template <> struct is_proto_enum< ::m_st::Pagetype> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::Pagetype>() {
  return ::m_st::Pagetype_descriptor();
}
template <> struct is_proto_enum< ::m_st::Font> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::Font>() {
  return ::m_st::Font_descriptor();
}
template <> struct is_proto_enum< ::m_st::BufferType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::m_st::BufferType>() {
  return ::m_st::BufferType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ui_2eproto
